# -*- coding: utf-8 -*-
"""Assignment2 - Copy.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TGHnSlb932OZcy-P_u_SdE9VomGhJI9c

# Importing Necessary Packages
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error
from sklearn.metrics import r2_score

from sklearn.preprocessing import StandardScaler
from sklearn.preprocessing import OneHotEncoder
from sklearn.preprocessing import TargetEncoder
from sklearn.impute import SimpleImputer
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline

"""# Data loading and exploration"""

# Load the data
df = pd.read_csv('hour.csv')
df.head()

# Information about the type of data
df.info()

# changing the type of some columns
df['dteday'] = pd.to_datetime(df['dteday'])
df['season'] = df['season'].astype('category')
df['yr'] = df['yr'].astype('category')
df['mnth'] = df['mnth'].astype('category')
df['hr'] = df['hr'].astype('category')
df['holiday'] = df['holiday'].astype('category')
df['weekday'] = df['weekday'].astype('category')
df['workingday'] = df['workingday'].astype('category')
df['weathersit'] = df['weathersit'].astype('category')

# information about the type of data
df.info()

"""# Data Preprocessing

## Missing Values
"""

# Checking for missing values
df.isnull().sum()

"""## Feature Engineering

Interaction variable:
- temp_humid (temp*hum): Temperature and humidity often have a combined effect on how comfortable or uncomfortable a day feels, which can influence the demand for bike rentals. For instance, a day with high temperature and high humidity might lead to lower rentals due to discomfort, even though the temperature alone might suggest itâ€™s a good day for biking.

-   atemp_windspeed (atemp*windspeed): The feeling temperature (atemp) is influenced by wind speed. On a windy day, the perceived temperature can be lower than the actual temperature, which can affect people's decision to rent bikes. By including this interaction, the model can account for days where a high wind speed may reduce the perceived warmth, potentially decreasing bike rentals.
"""

df["temp_humidity"] = df["temp"] * df["hum"]
df["atemp_windspeed"] = df["atemp"] * df["windspeed"]

# Spllitting the data into features and target
X = df.drop(['instant', 'dteday', 'cnt'], axis=1)
y = df['cnt']

# find the index of cateforical columns
categorical_features = X.select_dtypes(include=['category']).columns
categorical_features_index = [X.columns.get_loc(i) for i in categorical_features]

# find the index of numerical columns
numerical_features = X.select_dtypes(include=['float64', 'int64']).columns
numerical_features_index = [X.columns.get_loc(i) for i in numerical_features]

# categorical pipeline; step 1: Impute missing values, Step 2: OneHotEncode
categorical_pipeline_onehot = Pipeline(steps=[
    ('imputer', SimpleImputer(strategy='most_frequent')),
    ('onehot', OneHotEncoder(handle_unknown='ignore'))
])

categorical_pipeline_target = Pipeline(steps=[
    ('imputer', SimpleImputer(strategy='most_frequent')),
    ('onehot', TargetEncoder())
])

categorical_pipeline_onehot

categorical_pipeline_target

# numerical pipeline; step 1: Impute missing values, Step 2: Standardize
numerical_pipeline = Pipeline(steps=[
    ('imputer', SimpleImputer(strategy='mean')),
    ('scaler', StandardScaler())
])

numerical_pipeline

# Column Transformer with OneHotEncoding
preprocessor_with_onehot = ColumnTransformer(
    transformers=[
        ('num', numerical_pipeline, numerical_features_index),
        ('cat', categorical_pipeline_onehot, categorical_features_index)
    ])

preprocessor_with_onehot

# Column Transformer with TargetEncoding
preprocessor_with_target = ColumnTransformer(
    transformers=[
        ('num', numerical_pipeline, numerical_features_index),
        ('cat', categorical_pipeline_target, categorical_features_index)
    ])

preprocessor_with_target

"""# Model Integration to Data Pipeline and Model Training

## Inbulit Model Integration
"""

from sklearn.linear_model import LinearRegression

# Append classifier to preprocessing pipeline.
# Now we have a full prediction pipeline.
regression_model_onehot = Pipeline(steps=[('preprocessor', preprocessor_with_onehot),
                      ('classifier', LinearRegression())])

regression_model_onehot

# Append classifier to preprocessing pipeline.
# Now we have a full prediction pipeline.
regression_model_target = Pipeline(steps=[('preprocessor', preprocessor_with_target),
                      ('classifier', LinearRegression())])

regression_model_target

"""## Linear Model from Scratch"""

class LinearRegressionScratch:

    def __init__(self):
        self.coef_ = None
        self.intercept_ = None

    def fit(self,X_train,y_train):
        X_train = X_train.toarray()
        X_train = np.insert(X_train,0,1,axis=1)


        # calcuate the coeffs
        betas = np.linalg.inv(np.dot(X_train.T,X_train)).dot(X_train.T).dot(y_train)
        self.intercept_ = betas[0]
        self.coef_ = betas[1:]

    def predict(self,X_test):
        X_test = X_test.toarray()
        y_pred = np.dot(X_test,self.coef_) + self.intercept_
        return y_pred

# Attaching LinearRegressionScratch to the pipeline
regression_model_scratch_onehot = Pipeline(steps=[('preprocessor', preprocessor_with_onehot),
                      ('classifier', LinearRegressionScratch())])
regression_model_scratch_onehot

"""# Model Training"""

# Splitting the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Training the model
regression_model_onehot.fit(X_train, y_train)
regression_model_target.fit(X_train, y_train)
regression_model_scratch_onehot.fit(X_train, y_train)

"""# Model Evaluation"""

# Predicting the target using regression_model_onehot
y_pred_onehot = regression_model_onehot.predict(X_test)
y_pred_target = regression_model_target.predict(X_test)
y_pred_scratch_onehot = regression_model_scratch_onehot.predict(X_test)

# Evaluating the model
mse_onehot = mean_squared_error(y_test, y_pred_onehot)
r2_onehot = r2_score(y_test, y_pred_onehot)

print(f"Mean Squared Error: {mse_onehot}")
print(f"R^2 Score: {r2_onehot}")

# Evaluating the model
mse_target = mean_squared_error(y_test, y_pred_target)
r2_target = r2_score(y_test, y_pred_target)

print(f"Mean Squared Error: {mse_target}")
print(f"R^2 Score: {r2_target}")

# Evaluating the model
mse_scratch_onehot = mean_squared_error(y_test, y_pred_scratch_onehot)
r2_scratch_onehot = r2_score(y_test, y_pred_scratch_onehot)

print(f"Mean Squared Error: {mse_scratch_onehot}")
print(f"R^2 Score: {r2_scratch_onehot}")

# Export the results to a csv file
results = pd.DataFrame({
    'Model': ['RegressionModelOneHot', 'RegressionModelTarget', 'RegressionModelScratchOneHot'],
    'Mean Squared Error': [mse_onehot, mse_target, mse_scratch_onehot],
    'R^2 Score': [r2_onehot, r2_target, r2_scratch_onehot]
})